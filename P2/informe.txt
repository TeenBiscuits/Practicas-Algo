ALGORITMOS - PRÃCTICA 2

Pablo Portas Lopez
Pablo MÃ­guez MuÃ­Ã±o
Maite Liu GonzÃ¡lez VÃ¡zquez

1) Contexto
En esta prÃ¡ctica se implementaron y compararon dos algoritmos de ordenaciÃ³n: ordenaciÃ³n por
inserciÃ³n y ordenaciÃ³n rÃ¡pida (QuickSort). El objetivo fue analizar el rendimiento de estos
algoritmos midiendo los tiempos de ejecuciÃ³n en tres configuraciones iniciales del vector: orden
ascendente, orden descendente y valores aleatorios. Se utilizaron cotas teÃ³ricas n^1.8, n^2 y n^2.2
para comparar la eficiencia de los algoritmos.


2) Datos de la mÃ¡quina
Modelo de hardware: HP Victus by HP Gaming Laptop 15-fa0xxx
Memoria: 16.0 GiB
Procesador: 12th Gen IntelÂ® Coreâ„¢ i5-12500H Ã— 16
Nombre del SO: Ubuntu 22.04.5 LTS
VersiÃ³n del Kernel: 6.8.0-45-generic
Tipo de SO: 64 bits

Unidad de tiempo utilizada: micro segundos

3) ComprobaciÃ³n de los algoritmos
OrdenaciÃ³n por inserciÃ³n y ordenaciÃ³n rÃ¡pida: Se realizaron pruebas de ordenaciÃ³n en tres
configuraciones de inicializaciÃ³n del vector: aleatoria, descendente y ascendente. A continuaciÃ³n,
se muestran los resultados de estas pruebas para verificar la correcta implementaciÃ³n de los algoritmos.

--- Test 1 | OrdenaciÃ³n por inserciÃ³n ---
OrdenaciÃ³n con inicializaciÃ³n aleatoria
-6 15 4 -6 -1 18 -18 12 -9 19 -7 19 -9 17 -4 17 15 14 -4 8
Â¿Ordenado? 0
Ordenando...
-18 -9 -9 -7 -6 -6 -4 -4 -1 4 8 12 14 15 15 17 17 18 19 19
Â¿Ordenado? 1
Ordenando...
OrdenaciÃ³n con inicializaciÃ³n descendente
20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1
Â¿Ordenado? 0
Ordenando...
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Â¿Ordenado? 1


--- Test 2 | OrdenaciÃ³n rÃ¡pida ---
OrdenaciÃ³n con inicializaciÃ³n aleatoria
-6 15 4 -6 -1 18 -18 12 -9 19 -7 19 -9 17 -4 17 15 14 -4 8
Â¿Ordenado? 0
Ordenando...
-18 -9 -9 -7 -6 -6 -4 -4 -1 4 8 12 14 15 15 17 17 18 19 19
Â¿Ordenado? 1
Ordenando...
OrdenaciÃ³n con inicializaciÃ³n descendente
20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1
Â¿Ordenado? 0
Ordenando...
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Â¿Ordenado? 1

4) Tablas de tiempos:

1. PresentaciÃ³n de resultados de OrdenaciÃ³n por inserciÃ³n

OrdenaciÃ³n por inserciÃ³n con inicializaciÃ³n aleatoria
n               t(n)     t(n)/n^1.8       t(n)/n^2     t(n)/n^2.2
  500          0.895 0.000012407293 0.000003580000 0.000001032973 (*)
 1000          1.774 0.000007062421 0.000001774000 0.000000445609 (*)
 2000       1349.000 0.001542261288 0.000337250000 0.000073747272
 4000       6464.000 0.002122234466 0.000404000000 0.000076907619
 8000      16643.000 0.001569168700 0.000260046875 0.000043095670
16000      67682.000 0.001832555831 0.000264382813 0.000038142506
32000     301090.000 0.002341134531 0.000294033203 0.000036928901

* tiempo promedio en 1000 ejecuciones del algoritmo

OrdenaciÃ³n por inserciÃ³n con inicializaciÃ³n ascendente
n               t(n)     t(n)/n^1.8       t(n)/n^2     t(n)/n^2.2
  500          0.758 0.000010508076 0.000003032000 0.000000874853 (*)
 1000          1.931 0.000007687449 0.000001931000 0.000000485045 (*)
 2000          3.924 0.000004486163 0.000000981000 0.000000214518 (*)
 4000          6.808 0.000002235175 0.000000425500 0.000000081000 (*)
 8000         12.230 0.000001153093 0.000000191094 0.000000031669 (*)
16000         27.111 0.000000734057 0.000000105902 0.000000015279 (*)
32000         55.799 0.000000433867 0.000000054491 0.000000006844 (*)

* tiempo promedio en 1000 ejecuciones del algoritmo

OrdenaciÃ³n por inserciÃ³n con inicializaciÃ³n descendente
n               t(n)     t(n)/n^1.8       t(n)/n^2     t(n)/n^2.2
  500          1.046 0.000014500590 0.000004184000 0.000001207251 (*)
 1000        720.000 0.002866371628 0.000720000000 0.000180855823
 2000       1902.000 0.002174485522 0.000475500000 0.000103978733
 4000       7744.000 0.002542478915 0.000484000000 0.000092136851
 8000      35037.000 0.003303428692 0.000547453125 0.000090725410
16000     133731.000 0.003620896602 0.000522386719 0.000075364727
32000     547098.000 0.004253977281 0.000534275391 0.000067101955

* tiempo promedio en 1000 ejecuciones del algoritmo



1.1 Observaciones

//OrdenaciÃ³n por inserciÃ³n con inicializaciÃ³n aleatoria

-Crecimiento cuadrÃ¡tico esperado: Los tiempos de ejecuciÃ³n (t(n)) crecen significativamente a medida que aumenta
el tamaÃ±o de entrada n, lo que coincide con la complejidad teÃ³rica esperada del algoritmo de ordenaciÃ³n
por inserciÃ³n (ğ‘‚(ğ‘›^2)).

-DisminuciÃ³n de las cotas a medida que aumenta n:
Para cotas teÃ³ricas como ğ‘¡(ğ‘›)/ğ‘›1.8t(n)/n 1 .8, ğ‘¡(ğ‘›)/ğ‘›2t(n)/n 2 , y ğ‘¡(ğ‘›)/ğ‘›2.2t(n)/n 2.2, se observa
que los valores disminuyen a medida que n aumenta. Esto es coherente con la complejidad del
algoritmo: a mayor tamaÃ±o, los tiempos se ajustan mÃ¡s a la complejidad cuadrÃ¡tica ğ‘›^2, lo que hace
que los cocientes se estabilicen en valores mÃ¡s pequeÃ±os.

alores extremos: El tiempo de 1349.000 microsegundos para n = 2000 es considerablemente mÃ¡s alto que los
de n = 500 y n = 1000, lo que indica un comportamiento no lineal para los tamaÃ±os pequeÃ±os. Sin embargo, a partir
de n = 4000, el crecimiento de los tiempos parece mÃ¡s consistente.

//OrdenaciÃ³n por inserciÃ³n con inicializaciÃ³n ascendente

-Eficiencia mÃ¡xima: Dado que el vector ya estÃ¡ ordenado, los tiempos son significativamente menores comparados
con la inicializaciÃ³n aleatoria o descendente, lo que refleja el mejor caso para este algoritmo ğ‘‚(ğ‘›).
Este es el escenario ideal para la ordenaciÃ³n por inserciÃ³n.

-EstabilizaciÃ³n rÃ¡pida de las cotas: Las cotas t(n)/n^1.8, t(n)/n^2 y t(n)/n^2.2 son extremadamente pequeÃ±as, mostrando
que el tiempo real de ejecuciÃ³n es cercano a ğ‘‚(ğ‘›), como se esperarÃ­a en el caso de una lista ya ordenada.

-Tiempo lineal: A medida que n aumenta, el tiempo de ejecuciÃ³n sigue una tendencia casi lineal, lo cual es tÃ­pico del
mejor caso para este algoritmo.

//OrdenaciÃ³n por inserciÃ³n con inicializaciÃ³n descendente

El peor caso del algoritmo: Como se esperaba, este es el peor caso para la ordenaciÃ³n por inserciÃ³n, ya que el
algoritmo debe mover todos los elementos al principio del vector. El crecimiento en los tiempos es exponencialmente
mayor que en las otras dos inicializaciones.

Tiempos extremadamente largos para tamaÃ±os grandes: Para n = 32000, el tiempo de ejecuciÃ³n es de 547098 microsegundos, lo
que indica un crecimiento exponencialmente alto en comparaciÃ³n con los otros casos. Esto es consistente con el peor
caso de ğ‘‚(ğ‘›^2), ya que el vector estÃ¡ en el orden completamente opuesto al que el algoritmo requiere.

Las cotas t(n)/n^2 y t(n)/n^2.2 son significativamente mayores en los otros casos de inicalizaciÃ³n, lo que subraya la
ineficiencia del algoritmo para esta configuraciÃ³n


2. PresentaciÃ³n de resultados de OrdenaciÃ³n rÃ¡pida

OrdenaciÃ³n rÃ¡pida con inicializaciÃ³n aleatoria
n               t(n)     t(n)/n^1.8       t(n)/n^2     t(n)/n^2.2
  500         52.754 0.000731323261 0.000211016000 0.000060886553 (*)
 1000         38.314 0.000152530781 0.000038314000 0.000009624042 (*)
 2000         85.701 0.000097978751 0.000021425250 0.000004685111 (*)
 4000        174.782 0.000057383723 0.000010923875 0.000002079528 (*)
 8000        729.000 0.000068733040 0.000011390625 0.000001887685
16000       1613.000 0.000043673540 0.000006300781 0.000000909014
32000       2834.000 0.000022035854 0.000002767578 0.000000347592

* tiempo promedio en 1000 ejecuciones del algoritmo

OrdenaciÃ³n rÃ¡pida con inicializaciÃ³n ascendente
n               t(n)     t(n)/n^1.8       t(n)/n^2     t(n)/n^2.2
  500         18.326 0.000254051448 0.000073304000 0.000021151135 (*)
 1000         38.133 0.000151810207 0.000038133000 0.000009578577 (*)
 2000         83.024 0.000094918237 0.000020756000 0.000004538765 (*)
 4000        156.441 0.000051362080 0.000009777563 0.000001861310 (*)
 8000        326.122 0.000030748088 0.000005095656 0.000000844466 (*)
16000        729.000 0.000019738382 0.000002847656 0.000000410831
32000       1406.000 0.000010932396 0.000001373047 0.000000172447

* tiempo promedio en 1000 ejecuciones del algoritmo

OrdenaciÃ³n rÃ¡pida con inicializaciÃ³n descendente
n               t(n)     t(n)/n^1.8       t(n)/n^2     t(n)/n^2.2
  500         16.147 0.000223844196 0.000064588000 0.000018636220 (*)
 1000         38.483 0.000153203582 0.000038483000 0.000009666493 (*)
 2000         85.716 0.000097995900 0.000021429000 0.000004685931 (*)
 4000        162.211 0.000053256463 0.000010138188 0.000001929960 (*)
 8000        334.261 0.000031515466 0.000005222828 0.000000865541 (*)
16000        513.000 0.000013889973 0.000002003906 0.000000289104
32000       1075.000 0.000008358695 0.000001049805 0.000000131850

* tiempo promedio en 1000 ejecuciones del algoritmo



2.1 Observaciones

//OrdenaciÃ³n rÃ¡pida con inicializaciÃ³n aleatoria

Crecimiento subcuadrÃ¡tico: A diferencia de la ordenaciÃ³n por inserciÃ³n, QuickSort muestra
un crecimiento mucho mÃ¡s suave. Los tiempos de ejecuciÃ³n ( t (n) ) aumentan de manera
subcuadrÃ¡tica a medida que crece n, lo que es coherente con la complejidad promedio
esperada de O(n logn).

EstabilizaciÃ³n de las cotas: Las cotas teÃ³ricas t(n) /n^1.8, t(n)/n^2, y t(n) /n^2.2 disminuyen
gradualmente conforme n aumenta, lo que sugiere que el tiempo de ejecuciÃ³n tiende a
seguir la curva de ğ‘‚(ğ‘› log ğ‘›) en lugar de ğ‘‚(ğ‘›) . Esto es un indicador positivo de la
eficiencia de QuickSort en este escenario aleatorio

Comportamiento consistente: Desde n = 500 hasta n = 32000, se observa una reducciÃ³n constante
en las cotas, lo que confirma que el algoritmo mantiene su eficiencia a lo largo de diferentes tamaÃ±os de entrada.

//OrdenaciÃ³n rÃ¡pida con inicializaciÃ³n ascendente

Comportamiento similar al caso aleatorio: Aunque el vector ya estÃ¡ ordenado, los tiempos de ejecuciÃ³n y las cotas
se comportan de manera muy similar al caso de inicializaciÃ³n aleatoria. Esto es porque QuickSort no es particularmente
sensible a la ordenaciÃ³n previa del vector, siempre que se elija el pivote de forma aleatoria o adecuada.

Tiempos de ejecuciÃ³n ligeramente menores: En comparaciÃ³n con la inicializaciÃ³n aleatoria, los tiempos de ejecuciÃ³n
para la inicializaciÃ³n ascendente tienden a ser ligeramente menores. Esto podrÃ­a deberse a una menor cantidad de
intercambios o particiones durante la ordenaciÃ³n.

Las cotas teÃ³ricas disminuyen: De manera consistente, las cotas t(n)/n^1.8, t(n)/n^2, y
t(n) /n^2.2 se estabilizan a medida que aumenta el tamaÃ±o del vector, lo que confirma un
comportamiento subcuadrÃ¡tico esperado.

5) ConclusiÃ³n
La ordenaciÃ³n por inserciÃ³n es muy eficiente cuando los datos estÃ¡n casi ordenados o en orden ascendente, alcanzando
una complejidad cercana a ğ‘‚(ğ‘›), lo que la hace adecuada para conjuntos pequeÃ±os o medianos de datos ordenados. Sin
embargo, su rendimiento se degrada rÃ¡pidamente cuando los datos estÃ¡n completamente desordenados o en orden descendente,
mostrando una complejidad cuadrÃ¡tica ğ‘‚(ğ‘›2) que la vuelve ineficaz para grandes volÃºmenes de datos no ordenados. Por otro
lado, QuickSort ofrece un rendimiento mucho mÃ¡s robusto y versÃ¡til, con una complejidad promedio de ğ‘‚(ğ‘› log ğ‘›), siendo
eficiente incluso en grandes conjuntos de datos, sin importar el estado inicial (ascendente, descendente o aleatorio).
Aunque QuickSort tiene un peor caso teÃ³rico de ğ‘‚(ğ‘›^2), esto rara vez ocurre en la prÃ¡ctica si se usa un esquema adecuado
de selecciÃ³n de pivote. En resumen, mientras la ordenaciÃ³n por inserciÃ³n es adecuada para datos casi ordenados o de pequeÃ±o
tamaÃ±o, QuickSort es generalmente superior por su capacidad para manejar grandes volÃºmenes de datos de forma rÃ¡pida y consistente
en la mayorÃ­a de los escenarios.








